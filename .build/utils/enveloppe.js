"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class Enveloppe {
  constructor(targetParam, duration, breakpoints) {
    this.targetParam = targetParam;
    this.duration = duration;
    this.breakpoints = breakpoints;
  }

  test(startTime) {
    this.targetParam.setValueAtTime(0, startTime);
    this.targetParam.linearRampToValueAtTime(1, startTime + 3);
  }

  apply(startTime) {
    let prevTimeNT = this.breakpoints[0][0];
    let prevVal = this.breakpoints[0][1];
    this.targetParam.setValueAtTime(prevVal, startTime);

    for (let bp = 1; bp < this.breakpoints.length; bp++) {
      const [endTimeNT, targetVal, curve] = this.breakpoints[bp]; //endTime is normalized wrt to total duration of enveloppe and relative to start time
      //NT suffix refers to "normalized time"
      //All calculations for curve are made in normalized time

      const [prevTimeNT, prevVal, prevCurve] = this.breakpoints[bp - 1];

      if (Math.abs(curve) < 0.005) {
        this.targetParam.linearRampToValueAtTime(targetVal, startTime + endTimeNT * this.duration);
      } else if (curve > 0) {
        //recreating max/msp's curve~. see https://cycling74.com/forums/math-behind-function-curve
        const transDurNT = endTimeNT - prevTimeNT;
        let currTimeNT = prevTimeNT;
        const stepRealTime = 0.1; //Doing linear approximation of the curve with this step (in seconds of real time) 

        const timeIncrementNT = stepRealTime / this.duration;

        while (endTimeNT - currTimeNT > timeIncrementNT) {
          currTimeNT += timeIncrementNT;
          const gx = (currTimeNT - prevTimeNT) / transDurNT;
          const hp = Math.pow((curve + 1e-20) * 1.2, 0.41) * 0.91;
          const fp = hp / (1.0 - hp);
          const gp = (Math.exp(fp * gx) - 1.0) / (Math.exp(fp) - 1.0);
          const val = prevVal + gp * (targetVal - prevVal);
          this.targetParam.linearRampToValueAtTime(val, startTime + currTimeNT * this.duration);
        } //Last step


        this.targetParam.linearRampToValueAtTime(targetVal, startTime + endTimeNT * this.duration);
      } else {
        const transDurNT = endTimeNT - prevTimeNT;
        let currTimeNT = prevTimeNT;
        const stepRealTime = 0.1; //Doing linear approximation of the curve with this step (in seconds of real time) 

        const timeIncrementNT = stepRealTime / this.duration;

        while (endTimeNT - currTimeNT > timeIncrementNT) {
          currTimeNT += timeIncrementNT;
          const gx = (endTimeNT - currTimeNT) / transDurNT;
          const hp = Math.pow((1e-20 - curve) * 1.2, 0.41) * 0.91;
          const fp = hp / (1.0 - hp);
          const gp = (Math.exp(fp * gx) - 1.0) / (Math.exp(fp) - 1.0);
          const val = targetVal - gp * (targetVal - prevVal);
          this.targetParam.linearRampToValueAtTime(val, startTime + currTimeNT * this.duration);
        } //Last step


        this.targetParam.linearRampToValueAtTime(targetVal, startTime + endTimeNT * this.duration);
      }
    }
  }

}

exports.default = Enveloppe;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVudmVsb3BwZS5qcyJdLCJuYW1lcyI6WyJFbnZlbG9wcGUiLCJjb25zdHJ1Y3RvciIsInRhcmdldFBhcmFtIiwiZHVyYXRpb24iLCJicmVha3BvaW50cyIsInRlc3QiLCJzdGFydFRpbWUiLCJzZXRWYWx1ZUF0VGltZSIsImxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lIiwiYXBwbHkiLCJwcmV2VGltZU5UIiwicHJldlZhbCIsImJwIiwibGVuZ3RoIiwiZW5kVGltZU5UIiwidGFyZ2V0VmFsIiwiY3VydmUiLCJwcmV2Q3VydmUiLCJNYXRoIiwiYWJzIiwidHJhbnNEdXJOVCIsImN1cnJUaW1lTlQiLCJzdGVwUmVhbFRpbWUiLCJ0aW1lSW5jcmVtZW50TlQiLCJneCIsImhwIiwicG93IiwiZnAiLCJncCIsImV4cCIsInZhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFlLE1BQU1BLFNBQU4sQ0FBZ0I7QUFDN0JDLEVBQUFBLFdBQVcsQ0FBQ0MsV0FBRCxFQUFjQyxRQUFkLEVBQXdCQyxXQUF4QixFQUFvQztBQUM3QyxTQUFLRixXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS0MsV0FBTCxHQUFtQkEsV0FBbkI7QUFDRDs7QUFFREMsRUFBQUEsSUFBSSxDQUFDQyxTQUFELEVBQVk7QUFDZCxTQUFLSixXQUFMLENBQWlCSyxjQUFqQixDQUFnQyxDQUFoQyxFQUFtQ0QsU0FBbkM7QUFDQSxTQUFLSixXQUFMLENBQWlCTSx1QkFBakIsQ0FBeUMsQ0FBekMsRUFBNENGLFNBQVMsR0FBQyxDQUF0RDtBQUNEOztBQUVERyxFQUFBQSxLQUFLLENBQUNILFNBQUQsRUFBWTtBQUNmLFFBQUlJLFVBQVUsR0FBRyxLQUFLTixXQUFMLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQWpCO0FBQ0EsUUFBSU8sT0FBTyxHQUFHLEtBQUtQLFdBQUwsQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FBZDtBQUNBLFNBQUtGLFdBQUws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LEVBQUUsR0FBRyxDQUFDVixJQUFJLENBQUNXLEdBQUwsQ0FBU0YsRUFBRSxHQUFHSCxFQUFkLElBQW9CLEdBQXJCLEtBQTZCTixJQUFJLENBQUNXLEdBQUwsQ0FBU0YsRUFBVCxJQUFlLEdBQTVDLENBQVg7QUFDQSxnQkFBTUcsR0FBRyxHQUFHZixTQUFTLEdBQUdhLEVBQUUsSUFBRWIsU0FBUyxHQUFDSixPQUFaLENBQTFCO0FBRUEsZUFBS1QsV0FBTCxDQUFpQk0sdUJBQWpCLENBQXlDc0IsR0FBekMsRUFBOEN4QixTQUFTLEdBQUdlLFVBQVUsR0FBQyxLQUFLbEIsUUFBMUU7QUFDRCxTQWRJLENBZUw7OztBQUNBLGFBQUtELFdBQUwsQ0FBaUJNLHVCQUFqQixDQUF5Q08sU0FBekMsRUFBb0RULFNBQVMsR0FBR1EsU0FBUyxHQUFDLEtBQUtYLFFBQS9FO0FBQ0Q7QUFDRjtBQUNGOztBQWhFNEIiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBFbnZlbG9wcGUge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXRQYXJhbSwgZHVyYXRpb24sIGJyZWFrcG9pbnRzKXtcbiAgICB0aGlzLnRhcmdldFBhcmFtID0gdGFyZ2V0UGFyYW07XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuYnJlYWtwb2ludHMgPSBicmVha3BvaW50cztcbiAgfVxuXG4gIHRlc3Qoc3RhcnRUaW1lKSB7XG4gICAgdGhpcy50YXJnZXRQYXJhbS5zZXRWYWx1ZUF0VGltZSgwLCBzdGFydFRpbWUpO1xuICAgIHRoaXMudGFyZ2V0UGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMSwgc3RhcnRUaW1lKzMpO1xuICB9XG5cbiAgYXBwbHkoc3RhcnRUaW1lKcKge1xuICAgIGxldCBwcmV2VGltZU5UID0gdGhpcy5icmVha3BvaW50c1swXVswXTtcbiAgICBsZXQgcHJldlZhbCA9IHRoaXMuYnJlYWtwb2ludHNbMF1bMV07XG4gICAgdGhpcy50YXJnZXRQYXJhbS5zZXRWYWx1ZUF0VGltZShwcmV2VmFsLCBzdGFydFRpbWUpO1xuICAgIGZvciAobGV0IGJwID0gMTsgYnAgPCB0aGlzLmJyZWFrcG9pbnRzLmxlbmd0aDsgYnArKykge1xuICAgICAgY29uc3QgW2VuZFRpbWVOVCwgdGFyZ2V0VmFsLCBjdXJ2ZV0gPSB0aGlzLmJyZWFrcG9pbnRzW2JwXTsgXG4gICAgICAvL2VuZFRpbWUgaXMgbm9ybWFsaXplZCB3cnQgdG8gdG90YWwgZHVyYXRpb24gb2YgZW52ZWxvcHBlIGFuZCByZWxhdGl2ZSB0byBzdGFydCB0aW1lXG4gICAgICAvL05UIHN1ZmZpeCByZWZlcnMgdG8gXCJub3JtYWxpemVkIHRpbWVcIlxuICAgICAgLy9BbGwgY2FsY3VsYXRpb25zIGZvciBjdXJ2ZSBhcmUgbWFkZSBpbiBub3JtYWxpemVkIHRpbWVcblxuICAgICAgY29uc3QgW3ByZXZUaW1lTlQsIHByZXZWYWwsIHByZXZDdXJ2ZV0gPSB0aGlzLmJyZWFrcG9pbnRzW2JwLTFdOyBcbiAgICAgIFxuICAgICAgaWYgKE1hdGguYWJzKGN1cnZlKSA8IDAuMDA1KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0UGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGFyZ2V0VmFsLCBzdGFydFRpbWUgKyBlbmRUaW1lTlQqdGhpcy5kdXJhdGlvbik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjdXJ2ZSA+IDApIHsgXG4gICAgICAgIC8vcmVjcmVhdGluZyBtYXgvbXNwJ3MgY3VydmV+LiBzZWUgaHR0cHM6Ly9jeWNsaW5nNzQuY29tL2ZvcnVtcy9tYXRoLWJlaGluZC1mdW5jdGlvbi1jdXJ2ZVxuICAgICAgICBjb25zdCB0cmFuc0R1ck5UID0gZW5kVGltZU5ULXByZXZUaW1lTlQ7XG4gICAgICAgIGxldCBjdXJyVGltZU5UID0gcHJldlRpbWVOVDtcbiAgICAgICAgY29uc3Qgc3RlcFJlYWxUaW1lID0gMC4xICAvL0RvaW5nIGxpbmVhciBhcHByb3hpbWF0aW9uIG9mIHRoZSBjdXJ2ZSB3aXRoIHRoaXMgc3RlcCAoaW4gc2Vjb25kcyBvZiByZWFsIHRpbWUpIFxuICAgICAgICBjb25zdCB0aW1lSW5jcmVtZW50TlQgPSBzdGVwUmVhbFRpbWUvdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgd2hpbGUgKGVuZFRpbWVOVC1jdXJyVGltZU5UID4gdGltZUluY3JlbWVudE5UKSB7XG4gICAgICAgICAgY3VyclRpbWVOVCArPSB0aW1lSW5jcmVtZW50TlQ7XG4gICAgICAgICAgY29uc3QgZ3ggPSAoY3VyclRpbWVOVCAtIHByZXZUaW1lTlQpL3RyYW5zRHVyTlQ7XG4gICAgICAgICAgY29uc3QgaHAgPSBNYXRoLnBvdygoY3VydmUgKyAxZS0yMCkgKiAxLjIsIDAuNDEpKjAuOTE7XG4gICAgICAgICAgY29uc3QgZnAgPSBocCAvICgxLjAgLSBocCk7XG4gICAgICAgICAgY29uc3QgZ3AgPSAoTWF0aC5leHAoZnAgKiBneCkgLSAxLjApIC8gKE1hdGguZXhwKGZwKSAtIDEuMCk7XG4gICAgICAgICAgY29uc3QgdmFsID0gcHJldlZhbCArIGdwICogKHRhcmdldFZhbC1wcmV2VmFsKTtcblxuICAgICAgICAgIHRoaXMudGFyZ2V0UGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsLCBzdGFydFRpbWUgKyBjdXJyVGltZU5UKnRoaXMuZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vTGFzdCBzdGVwXG4gICAgICAgIHRoaXMudGFyZ2V0UGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGFyZ2V0VmFsLCBzdGFydFRpbWUgKyBlbmRUaW1lTlQqdGhpcy5kdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0cmFuc0R1ck5UID0gZW5kVGltZU5ULXByZXZUaW1lTlQ7XG4gICAgICAgIGxldCBjdXJyVGltZU5UID0gcHJldlRpbWVOVDtcbiAgICAgICAgY29uc3Qgc3RlcFJlYWxUaW1lID0gMC4xICAvL0RvaW5nIGxpbmVhciBhcHByb3hpbWF0aW9uIG9mIHRoZSBjdXJ2ZSB3aXRoIHRoaXMgc3RlcCAoaW4gc2Vjb25kcyBvZiByZWFsIHRpbWUpIFxuICAgICAgICBjb25zdCB0aW1lSW5jcmVtZW50TlQgPSBzdGVwUmVhbFRpbWUvdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgd2hpbGUgKGVuZFRpbWVOVC1jdXJyVGltZU5UID4gdGltZUluY3JlbWVudE5UKSB7XG4gICAgICAgICAgY3VyclRpbWVOVCArPSB0aW1lSW5jcmVtZW50TlQ7XG4gICAgICAgICAgY29uc3QgZ3ggPSAoZW5kVGltZU5UIC0gY3VyclRpbWVOVCkvdHJhbnNEdXJOVDtcbiAgICAgICAgICBjb25zdCBocCA9IE1hdGgucG93KCgxZS0yMCAtIGN1cnZlKSAqIDEuMiwgMC40MSkgKiAwLjkxO1xuICAgICAgICAgIGNvbnN0IGZwID0gaHAgLyAoMS4wIC0gaHApO1xuICAgICAgICAgIGNvbnN0IGdwID0gKE1hdGguZXhwKGZwICogZ3gpIC0gMS4wKSAvIChNYXRoLmV4cChmcCkgLSAxLjApO1xuICAgICAgICAgIGNvbnN0IHZhbCA9IHRhcmdldFZhbCAtIGdwKih0YXJnZXRWYWwtcHJldlZhbCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy50YXJnZXRQYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWwsIHN0YXJ0VGltZSArIGN1cnJUaW1lTlQqdGhpcy5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy9MYXN0IHN0ZXBcbiAgICAgICAgdGhpcy50YXJnZXRQYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0YXJnZXRWYWwsIHN0YXJ0VGltZSArIGVuZFRpbWVOVCp0aGlzLmR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==